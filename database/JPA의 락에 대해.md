# JPA의 LOCK에 대해(feat.트랜잭션)

락은 동시성 제어를 위해 필요하다.
-> 트랜잭션들이 동시에 수행될 때 일관성을 해치지 않도록.
-> 트랜잭션이 완전한 격리를 보장하기 위해, 동시성 측면에서 많은 손실을 감내한다.

## 트랜잭션의 격리 수준으로 해결 불가능한 문제 - lost update problem
흔히 '갱신 분실' 문제라고도 불린다.

두 트랜잭션이 동시에 공유 자원을 수정하려고 할 경우 발생한다.
일반적으로는 마지막에 반영된 커밋이 적용되고, 이전 커밋의 결과는 반영되지 않는다.

이를 해결하기 위해 다른 방법이 있을까?
1. 최초의 커밋만 인정하기
2. 충돌 내용 병합

하지만, 트랜잭션의 격리 수준을 높여도 결국 위에 제시한 방법은 적용할 수 없다.

### 예시 시나리오 - 뱅킹 시스템
만약 계좌를 송금해야 하는 시나리오를 생각해보자.
A는 트랜잭션에 3만원을 입급하고, B는 트랜잭션에 5만원을 입금하려고 한다.
만약 이를 동시에 진행한다면, A와 B는 각각 현재 잔액에서 각 금액을 입금해 커밋한다.

이때, A가 먼저 커밋했다면, A의 송금 내역은 lost된다.

트랜잭션 격리 레벨을 높이면 어떻게 되는가?
기존 MySQL의 DEFAULT LEVEL인 REPEATABLE READ는 조회한 데이터가 트랜잭션 동안 일관적으로 같은 값을 읽어온다.

이를 SERIALIZABLE로 높인다는 것은, 읽기 작업을 하는 데이터에 대해서도 공유락을 건다.

만약 이를 적용한다면 A와 B 트랜잭션은 같은 데이터에 대해 s-lock을 걸고, 서로 쓰기를 위해 x-lock을 건다.
이때 deadlock이 발생한다. 두 트랜잭션은 x-lock을 위해 s-lock이 해제되는 시점을 기다리면서 데드락에 빠진다.

## 낙관적 락(Optimisstic Lock)

* 데이터 갱신 시 경합이 발생하지 않을 것이라고 본다.
* non-blocking하게 작동한다.

데이터를 업데이트 하기 전, 버전 정보를 다시 read 한다.
처음 읽어온 버전과 다시 읽어온 버전이 동일한 경우 -> update 가능
처음 읽어온 버전과 다시 읽은 버전이 다른 경우 -> update 불가(충돌 발생, 롤백 처리)

* 충돌이 발생하면 예외가 발생하므로, 이에 대한 후속 처리가 필요하다.

## JPA의 @Version
- JPA의 @Version 어노테이션은 Long, Integer, Short, Timestamp에 적용할 수 있다.

```java

@Entity
public class Member {
    @Id
    private Long id;
    private String name;
    
    @Version
    private Long version;
}
```

이를 통해 업데이트 시점에 대한 버전 정보를 기록하여 낙관적 락을 구현할 수 있다.
* 벌크 연산 시에는 버전을 무시하므로, 버전 필드를 강제로 증가시켜야 함.

## 낙관적 락의 LockModeType - 락 옵션

* NONE
  * 엔티티를 수정하는 시점에 엔티티의 버전을 증가, 조회 시점과 다르다면 예외 발생
* OPTIMISTIC
  * 트랜잭션을 커밋하는 시점에 버전정보를 체크(조회 시에도 버전 체킹)
* OPTIMISTIC_FORCE_INCREMENT
  * 낙관적 락을 사용하면서 버전 정보를 강제로 증가한다.
  * 엔티티가 물리적으로 변경되지 않았지만, 논리적으로 변경되었을 경우 버전을 증가하고 싶을 때 사용
  * EX. 게시물에 이미지가 추가된 상황(엔티티에 직접 수정이 일어나지 않음.)

## 비관적 락(Pessimistic Lock)

* 동일한 데이터를 동시에 수정할 가능성이 높다고 본다.
* 데이터에 접근하기 전 먼저 락을 건다.
  * 다른 사용자의 경우 해당 락이 풀릴 때까지 대기한다.

## 비관적 락의 LockModeType
* PESSIMISTIC_WRITE
  * SELECT ... FOR UPDATE를 이용해 배타락을 건다.
  * NON-REPEATABLE READ를 방지한다.
* PESSIMISTIC_READ
  * SELECT ... FOR SHARE(LOCK IN SHARE MODE)
  * 데이터를 반복 읽기만 하고, 수정하지 않을 때 사용. 거의 사용하지 않음.
* PESSIMISTIC_FORCE_INCREMENT
  * 비관적 락에서 버전 정보를 강제적으로 증가.

## 비관적 락 연산의 종류(공유락, 배타락)

* 공유락(shared lock, s-lock)
  * 읽기 잠금
  * read 연산 실행 가능, write 연산 실행 불가능
    * 다른 트랜잭션의 경우 **조회는** db의 무결성에 영향이 없기 때문에 가능하다.
  * 데이터에 대한 사용권을 여러 트랜잭션이 함께 가질 수 있다.
  * 조회가 가능하므로, 만약 조회 후 동시 수정 시 문제가 발생 가능하다.(예외 처리)

* 배타락(exclusive lock, x-lock)
  * read 연산과 write 연산을 모두 실행 가능.
    * 다른 트랜잭션은 둘다 불가능하다.
  * **데드락 발생 가능성이 높으므로**, 잠금 시간 조절, 트랜잭션 크기 관리 등이 필요함.
    * 시간이 짧으면 요청이 빈번하게 실패, 길면 일정 수준의 데드락을 허용할 것이다 -> 성능 문제 발생

각 락은 다른 락과 양립 가능한가?
|  -  | 공유락 | 배타락  |
|:---:|:---:|:----:|
| 공유락 | 가능  | 불가능  |
| 배타락 | 불가능 | 불가능  |

## 무슨 차이인가?
낙관적 락은 동시 업데이트가 거의 없는 경우 사용하면 좋다.
-> 업데이트가 잦으면 자원을 획득하기 위해서 계속 재시도하는 `busy wait`이 자주 일어난다.

비관적 락은 동시 업데이트가 빈번하거나 혹은 외부 API와 연동한 경우 사용하면 좋다.

## Blocking
* 배타락이 걸리면 타 트랜잭션은 lock을 걸지 못하고 대기 큐에서 대기.

해결 방법은?
* 트랜잭션의 크기를 축소
* 같은 데이터를 갱신하는 트랜잭션이 동시에 수행되지 않도록 설계
* LOCK TIMEOUT을 이용하여 잠금해제 시간 조절

## 트랜잭션 VS JPA의 동시성 제어
JPA의 동시성 제어 메커니즘은 **특정 엔티티에 대한 동시 접근**을 막기 위해 사용한다. 
반면, 트랜잭션 격리 수준은 **트랜잭션 동안의 일관된 데이터 읽기를 고려하기 위해 적용**한다.

### Reference
* Real MySQL 8.0
* https://www.youtube.com/watch?v=ZXV6ZqMyJLg
* https://hudi.blog/jpa-concurrency-control-optimistic-lock-and-pessimistic-lock/